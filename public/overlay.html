<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OBS Ticker</title>
<style>
body {
    margin: 0;
    background: transparent;
    overflow: hidden;
    font-family: monospace;
}

.ticker-container {
    position: relative;
    width: 100%;
    height: 50px; /* Adjust height as needed */
    overflow: hidden;
}

.ticker-text {
    font-size: 36px;
    color: #00ff00;
    text-shadow: 2px 2px 4px black;
    white-space: nowrap;
    position: absolute;
    left: 0;
    top: 50%;
    will-change: transform;
}
</style>
</head>
<body>
<div class="ticker-container">
    <div class="ticker-text" id="ticker">Welcome to the Stream!</div>
</div>

<script>
const ticker = document.getElementById('ticker');

// Full-width continuous scrolling
let containerWidth = window.innerWidth;
let tickerWidth = ticker.offsetWidth;
let position = containerWidth;
let speed = 2;

// Duplicate for smooth looping
const duplicate = ticker.cloneNode(true);
duplicate.id = 'ticker-duplicate';
ticker.parentNode.appendChild(duplicate);

function scrollTicker() {
    position -= speed;
    if(position < -tickerWidth) {
        position = containerWidth;
    }
    ticker.style.transform = `translateX(${position}px) translateY(-50%)`;
    duplicate.style.transform = `translateX(${position + tickerWidth + 100}px) translateY(-50%)`;
    requestAnimationFrame(scrollTicker);
}

// Handle resize
window.addEventListener('resize', () => {
    containerWidth = window.innerWidth;
    tickerWidth = ticker.offsetWidth;
    position = containerWidth;
});

scrollTicker();

// Socket.io for real-time updates
const script = document.createElement('script');
script.src = '/socket.io/socket.io.js';
script.onload = function() {
    const socket = io();
    const urlParams = new URLSearchParams(window.location.search);
    const room = urlParams.get('room') || 'default';
    
    // Join room
    socket.emit('join', room);
    
    // Listen for updates from control panel
    socket.on('update', (data) => {
        if(data.text) {
            ticker.textContent = data.text;
            duplicate.textContent = data.text;
            // Wait a frame for the DOM to update before measuring
            requestAnimationFrame(() => {
                tickerWidth = ticker.offsetWidth;
                position = containerWidth;
            });
        }
        if(data.color) {
            ticker.style.color = data.color;
            duplicate.style.color = data.color;
        }
        if(data.fontSizePx) {
            ticker.style.fontSize = data.fontSizePx + 'px';
            duplicate.style.fontSize = data.fontSizePx + 'px';
        }
        if(data.fontFamily) {
            ticker.style.fontFamily = data.fontFamily;
            duplicate.style.fontFamily = data.fontFamily;
        }
        if(data.speed) {
            // Update speed (this is a simple implementation)
            speed = data.speed / 50; // Convert from px/sec to animation speed
        }
    });
};
document.head.appendChild(script);
</script>
</body>
</html>
